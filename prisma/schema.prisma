// Prisma Schema for League Ladder
// PostgreSQL database for production and development
// Connection URL is configured via DATABASE_URL environment variable
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Define custom output path for generated Prisma Client
generator client {
  provider = "prisma-client-js"
  engineType = "binary"
  // Explicitly disable edge runtime to prevent "client" engine type detection
  // This ensures we always use binary engine, not client engine (which requires adapter)
}

// NextAuth.js tables
model User {
  id            String    @id @default(uuid())
  name          String?
  email         String    @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  isAdmin       Boolean   @default(false) @map("is_admin")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @default(now()) @updatedAt @map("updated_at")

  accounts      Account[]
  sessions      Session[]
  players       Player[]
  adminActions  AdminAction[] @relation("UserAdminActions")

  @@map("users")
}

model Account {
  id                String  @id @default(uuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refreshToken      String? @map("refresh_token")
  accessToken       String? @map("access_token")
  expiresAt         Int?    @map("expires_at")
  tokenType         String? @map("token_type")
  scope             String?
  idToken           String? @map("id_token")
  sessionState      String? @map("session_state")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// Application tables
model Player {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  name      String
  email     String?  @unique
  avatar    String?
  createdAt DateTime @default(now()) @map("created_at")

  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  memberships    LeagueMembership[]
  ratings        PlayerRating[]
  challengesSent Challenge[]         @relation("Challenger")
  challengesReceived Challenge[]      @relation("Challengee")
  matchesAsPlayer1 Match[]            @relation("Player1")
  matchesAsPlayer2 Match[]            @relation("Player2")
  matchesWon      Match[]             @relation("Winner")
  matchesReported  Match[]             @relation("Reporter")
  matchConfirmations MatchConfirmation[]
  ratingUpdates   RatingUpdate[]

  @@unique([userId, name])
  @@map("players")
}

model League {
  id        String   @id
  name      String   @unique
  gameType  String   @map("game_type")
  createdAt DateTime @default(now()) @map("created_at")

  memberships LeagueMembership[]
  ratings     PlayerRating[]
  challenges  Challenge[]
  matches     Match[]
  ratingUpdates RatingUpdate[]

  @@map("leagues")
}

model LeagueMembership {
  id       String   @id @default(uuid())
  playerId String   @map("player_id")
  leagueId String   @map("league_id")
  joinedAt DateTime @default(now()) @map("joined_at")
  isActive Boolean  @default(true) @map("is_active")

  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  league League @relation(fields: [leagueId], references: [id], onDelete: Cascade)

  @@unique([playerId, leagueId])
  @@map("league_memberships")
}

model PlayerRating {
  id          String   @id @default(uuid())
  playerId   String   @map("player_id")
  leagueId   String   @map("league_id")
  rating     Int      @default(1000)
  gamesPlayed Int      @default(0) @map("games_played")
  wins       Int      @default(0)
  losses     Int      @default(0)
  draws      Int      @default(0)
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  league League @relation(fields: [leagueId], references: [id], onDelete: Cascade)

  @@unique([playerId, leagueId])
  @@map("player_ratings")
}

model Challenge {
  id         String    @id @default(uuid())
  challengerId String  @map("challenger_id")
  challengeeId String  @map("challengee_id")
  leagueId   String    @map("league_id")
  status     String    @default("pending")
  createdAt  DateTime  @default(now()) @map("created_at")
  expiresAt  DateTime? @map("expires_at")

  challenger Player @relation("Challenger", fields: [challengerId], references: [id])
  challengee Player @relation("Challengee", fields: [challengeeId], references: [id])
  league     League @relation(fields: [leagueId], references: [id])
  match      Match?

  @@map("challenges")
}

model Match {
  id          String    @id @default(uuid())
  challengeId String?   @unique @map("challenge_id")
  player1Id   String    @map("player1_id")
  player2Id   String    @map("player2_id")
  leagueId    String    @map("league_id")
  player1Score Int      @map("player1_score")
  player2Score Int      @map("player2_score")
  winnerId    String?   @map("winner_id")
  status      String    @default("pending")
  reportedBy String?    @map("reported_by")
  playedAt    DateTime  @default(now()) @map("played_at")
  confirmedAt DateTime? @map("confirmed_at")

  challenge         Challenge?           @relation(fields: [challengeId], references: [id])
  player1           Player               @relation("Player1", fields: [player1Id], references: [id])
  player2           Player               @relation("Player2", fields: [player2Id], references: [id])
  winner            Player?              @relation("Winner", fields: [winnerId], references: [id])
  reporter          Player?              @relation("Reporter", fields: [reportedBy], references: [id])
  league            League               @relation(fields: [leagueId], references: [id])
  confirmations     MatchConfirmation[]
  ratingUpdates     RatingUpdate[]

  @@map("matches")
}

model MatchConfirmation {
  id             String   @id @default(uuid())
  matchId        String   @map("match_id")
  playerId       String   @map("player_id")
  action         String   // 'confirmed' or 'disputed'
  confirmedScore1 Int?    @map("confirmed_score1")
  confirmedScore2 Int?    @map("confirmed_score2")
  disputeReason  String?  @map("dispute_reason")
  createdAt      DateTime @default(now()) @map("created_at")

  match  Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)
  player Player @relation(fields: [playerId], references: [id])

  @@unique([matchId, playerId])
  @@map("match_confirmations")
}

model RatingUpdate {
  id        String   @id @default(uuid())
  matchId   String   @map("match_id")
  playerId  String   @map("player_id")
  leagueId  String   @map("league_id")
  oldRating Int      @map("old_rating")
  newRating Int      @map("new_rating")
  change    Int
  createdAt DateTime @default(now()) @map("created_at")

  match  Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)
  player Player @relation(fields: [playerId], references: [id])
  league League @relation(fields: [leagueId], references: [id])

  @@map("rating_updates")
}

model AdminAction {
  id        String   @id @default(uuid())
  userId    String?  @map("user_id")
  action    String
  targetId  String?  @map("target_id")
  details   String?
  createdAt DateTime @default(now()) @map("created_at")

  user User? @relation("UserAdminActions", fields: [userId], references: [id])

  @@map("admin_actions")
}
